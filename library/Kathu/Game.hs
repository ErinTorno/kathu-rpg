{-# LANGUAGE BangPatterns     #-}
{-# LANGUAGE DataKinds        #-}
{-# LANGUAGE ExplicitForAll   #-}
{-# LANGUAGE FlexibleContexts #-}

module Kathu.Game (runGame, updateDelay) where

import Apecs hiding (set)
import Apecs.Physics hiding (set)
--import Apecs.System (cmapIf)
import Control.Lens
import Control.Monad (when)
import Control.Monad.IO.Class (MonadIO)
import Data.Maybe
import Data.Word
--import Linear.V2 (V2(..))

import Kathu.Entity.Action
import Kathu.Entity.Components
import Kathu.Entity.Physics.Floor
import Kathu.Entity.System
import Kathu.Util.Apecs
import Kathu.World.Time (WorldTime)

updateDelay :: Word32
updateDelay = floor $ 1000 / (60 :: Double) -- 60 ticks per second is ideal

runPhysics :: forall w m. (MonadIO m, Get w m EntityCounter, Has w m Physics, HasEach w m '[ActionSet, FloorProperties, Local, MovingSpeed, WorldFloor])
           => SystemT w m ()
runPhysics = do
    (FloorProperties defFloorPropEty _) <- get global

    -- We assign the default floor to entities that have a WorldFloor that requests for it to be assigned
    cmapIfM isFloorUnassigned (assignWorldFloor defFloorPropEty)
    
    -- Updates ActionSet for the local player based on pressed 
    cmap $ \(as, Local press) ->
        let dir       = getDirection press
            facingDir = fromMaybe (as^.facingDirection) dir
         in set facingDirection facingDir . set moving dir . set lastMoving (as^.moving) $ as
    -- Applies for all moving acting entities
    -- cmap $ \(Velocity v) -> Velocity . zeroOutLowValues $ v
    cmap $ \(MovingSpeed s, Velocity v, Mass m, as) -> Force . getMoveVector v m s . view moving $ as

    -- cmapIf (\(body) -> body == DynamicBody) $ \(Velocity v) -> Velocity . applyFriction floorFrictionMu $ v

    pure ()
    
-- Unfortunately, we can't just use Physics, since the SystemT' generated by Apecs doesn't fulfill all the requirements?
runGame :: forall w m. (MonadIO m, Get w m EntityCounter, Has w m Physics, HasEach w m '[ActionSet, FloorProperties, LifeTime, Local, LogicTime, MovingSpeed, WorldFloor, WorldTime])
        => (Entity -> SystemT w m ()) -- We take a function to destroy an entity, since there are more components than this module knows about
        -> Word32
        -> SystemT w m ()
runGame destroyEntity !dT = do
    cmap   $ updateLifeTime dT
    cmapM_ $ \(life, ety) -> when (hasExpired life) (destroyEntity ety)
    stepLogicTime dT
    stepWorldTime dT
    runPhysics
    pure ()